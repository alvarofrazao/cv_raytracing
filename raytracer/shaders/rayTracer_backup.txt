#version 430

struct Sphere{
    vec3 center;
    float radius;
    vec3 color;
};

struct Plane{
    vec3 center;
    vec3 tangent;
    vec3 bitangent;
    vec3 normal;
    float uMin;
    float uMax;
    float vMin;
    float vMax;
    vec3 color;
};

struct Camera{
    vec3 position;
    vec3 forwards;
    vec3 right;
    vec3 up;
};

struct Ray{
    vec3 origin;
    vec3 direction;
};

struct RenderState{
    float t;
    vec3 color;
    bool hit;
};

// input/output
layout(local_size_x = 8, local_size_y = 8) in;
layout(rgba32f, binding = 0) uniform image2D img_output;

//Scene Data
uniform Camera viewer;
//uniform Sphere spheres[64];
layout(std430, binding = 1) readonly buffer sphereData{
    Sphere[] spheres;
};

layout(std430, binding = 2) readonly buffer planeData{
    Plane[] planes;
}

uniform float s_count;

vec3 rayColor(Ray ray);

RenderState hit(Ray ray, Sphere sphere, float tMin, float tMax, RenderState renderState);


void main() {

    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 screen_size = imageSize(img_output);

    float hCoef = ((float(pixel_coords.x) * 2 - screen_size.x)/screen_size.x);
    float vCoef = ((float(pixel_coords.y) * 2 - screen_size.y)/screen_size.x);


    Ray ray;
    ray.origin = viewer.position;
    ray.direction = viewer.forwards + hCoef * viewer.right + vCoef * viewer.up;

    vec3 pixel = rayColor(ray);

    imageStore(img_output, pixel_coords, vec4(pixel,1.0));
}

vec3 rayColor(Ray ray){

    vec3 color = vec3(0.0);

    float nearestHit = 999999;
    bool hitObject = false;
    RenderState renderState;

    for(int i = 0; i < s_count; i++){

        renderState =  hit(ray, spheres[i],0.001, nearestHit, renderState);

        if(renderState.hit) {
            nearestHit = renderState.t;
            hitObject = true;
        }
    }

    if(hitObject){
        color = renderState.color;
    }

    return color;
}

RenderState hit(Ray ray, Sphere sphere, float tMin, float tMax, RenderState renderState){

    vec3 co = ray.origin - sphere.center;
    float a = dot(ray.direction,ray.direction);
    float b = 2.0 * dot(ray.direction, co);
    float c = dot(co,co) - sphere.radius * sphere.radius;
    float delta = b*b - 4.0 * a * c;

    if(delta > 0.0){

        float t = (-b -sqrt(delta))/(2*a);

        if (t > tMin && t < tMax){
            renderState.t = t;
            renderState.color = sphere.color;
            renderState.hit = true;
            return renderState;
        }
    }

    renderState.hit = false;
    return renderState; 
}